title: 汤姆大叔设计模式学习体会：设计模式的思想
tags: []
date: 2014-02-08 08:32:00
---

**汤姆大叔的教程地址：[http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)，谢谢大叔。**

**1、单例模式**

核心是该对象只存在一个实例，要么直接写成实例的形式，

要么就需要写成构造函数形式，但是需要在构造函数里面通过模拟闭包的方式重新定义该构造函数，保存当前this对象，新定义的构造函数返回该this对象，达到只存在改对象只存在一个实例的目的。
<!--more-->
**2、构造者模式**

其实就一构造函数，记得首字母大写。

**3、建造者模式**

给你一块砖，你能砌上墙，给你十块砖，也能通过这个方法砌上墙。可能这些砖的颜色有点不同而已。这个方法，就是建造者模式。

砖的颜色怎么样，墙就怎么样，跟怎么建造没关系。给你同类型的砖，这个方法就能砌好这堵墙。

**4、工厂模式**

一个有钱的傻大壮，有一天看到想要一个三轮车，他爸给了他个能做任何车的车厂。

傻大壮跟厂长说：“给我个帅气的三轮车”，铛的一声，厂长给了他一辆自己厂生产的三轮车。

又一天，傻大壮想要一个拖拉机，厂长二话没说，拉出了刚下生产线的拖拉机。

傻大壮耍了几天，觉得拖拉机太快了，根厂长要量人力三轮车，厂长吩咐阿四把刚出产的人力三轮车骑了过来。

傻大壮要去泡妞啊，厂长觉得三轮车去泡妞太霸气了，要低调，哄傻大壮开个别的。傻大壮说：“那好，给我个法拉利”。 厂长笑了笑，又叫阿四拉出了最新研发的法拉利出来。

这个就是工厂，这个工厂就是一个模式，给什么要求，做什么东西，当然，你说飞机火箭什么的，劳驾到其它工厂吧。

不过嘛，你没有傻大壮的老爸，这个工厂需要你自己来搭建咯，先从自行车的刹车皮开始做起吧，慢慢来别急啊骚年。

**5、装饰者模式**

傻大壮一直有一个理念，只买贵的不买对的。

一天他朋友跟他说，他的劳斯莱斯改装过之后，价值比原来高了100快啊，然后又加了个高压发动机，价值又高了200快。总价从原来的400快变成700了。

傻大壮开不过眼，自己的法拉利再怎么说也是600快的价值，我也要改装，超过你们，结果傻大壮把车拿去改装：喷靓丽的骚红色车漆，价值+100、改装亮瞎前灯，价值+200，傻大壮觉得，反正已经900快价值了，比你的高。

这就是装饰者模式，把原车拿去，换了一个改装过的车。再把这车改装，这车又更加霸气了。不过来来回回都是那个车每一次改装都没有前提和前置条件。不过大叔的代码里面，前面的代码说的确实每一次的车都被克隆了一个，把克隆了之后的给了别人。后面使用了prototype才算正确。（个人疑惑点，大叔见谅，谢谢大叔指点。）

**6、外观模式**

将相同功能但是参数顺序数量格式不同或者功能名不同的功能集合起来，通过该功能即可自动识别调用该系统支持的接口，鉴于每次都需要进行支持性判断，损耗了部分的性能。但是大大方便了程序员的工作，大部分兼容框架都会使用到该模式。如下事件绑定代码：

```javascript
var addMyEvent = function (el, ev, fn) {
    if (el.addEventListener) {
        el.addEventListener(ev, fn, false);
    } else if (el.attachEvent) {
        el['e'+ev+fn]=fn;
        el[ev+fn]=function(e){el['e'+ev+fn](e||window.event);}
        el.attachEvent('on' + ev, el[ev+fn]);
    } else {
        el['e'+ev+fn]=fn;
        el[ev+fn]=function(e){el['e'+ev+fn](e||window.event);}
        el['on' + ev] = el[ev+fn];
    }
}; 
```

**7、代理模式**

大叔说了，dudu不敢送玫瑰花给酸奶小妹，大叔就帮他了。常用，不过把自己的命运交给别人把握的感觉不怎么好。

**8、观察者模式**

对于消息分发很有帮助，能通过一个地方的修改就改变其他地方。具体实现代码的时候直接模仿。

**9、策略模式**

把算法单独封装起来，区别于每次使用不使用这种模式构造的算法集都会影响用户使用。使用该种模式的话，能够方便的进行功能增加的测试，新增加的同类算法不影响现在的算法，大叔的文章中把输入验证的算法单独抽出实现算法集的集合，增加新验证方式又不影响现在算法。

**10、命令模式**

这个模式十分适合那种需要记录动作执行记录的功能，讲这个命令接口设置成字符串或者JSON格式，传输给命令接口，即可方便执行命令记录和执行命令的动作。命令格式还能自定义。

**11、迭代器模式**

主要思想是把一个属性不可修改的可遍历的聚合对象保护起来，在进行遍历时，需要采用该种模式。

该模式中，通过至少hasNext()和Next()两个方法，即可进行把一个聚合对象的所有可遍历属性遍历完毕。

**12、中介者模式**

使用中介封装其他对象的交互。大叔说道，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

耦合松散对编程来说那可是值得走的好方向，只是需要花点时间来解耦而已。

中介者模式和观察者模式有相同之处，都是通过消息驱动，用户出发一个对象的事件，传输到中介者，中介者分发下去，触发接受者的接受函数。其实我把两者混淆了。

重要特点是，中介者，多对多；观察者，一对多。

**13、享元模式**

方便的管理相同的层级元素。例如具备相同单元的对象及元素，能把其相同之处集合起来。还有管理 DOM 事件，利用 DOM 的冒泡和捕抓事件的特性。能把单独的小事件统一到其上一级别，通过判断 e.originalTarget 或者 e.srcElement 进行小事件的对应单独处理，但是要注意多次触发事件的问题。达到性能和内存的优化。

**14、职责链模式**

职责链就好像工厂的生产流水线，每到一个责任，都会有一个特定的接口，调用该接口就能自动通知下一任责任者就行责任的填充，每一个责任都知道其下一任职责者。最后一任职责者会调用完毕动作。

因此在使用职责链时，需要传入下一任职责者，生成对象，调用职责链的公用方法，通知下一任职责者。创建处事对象的时候，需要根据职责链的接口，设定动作函数。

**15、适配器模式**

该模式主要针对接口的改变，如果不想再原始对象上面进行变动，那就可以采取适配器的模式。把原有接口重新封装，实现用户需要的接口。

就比如一个三口插座充电器，在中国能用，在外国不能用了，就需要使用接口转换的了，现在的高端手机基本上都有多口转换。充电器到头来还是那个充电器。

**16、组合模式**

大叔说道，组合模式有明确的使用场景：1、你想表达对象的部分-整体层次结构时。2、组合对象和单个对象不同，但是使用的时候能相同使用。具体实现时需要先写一个最基础的组合方法，然后后面的单个对象的基础对象都需要继承该方法。详细实现时，参考大叔的菜单代码。

**17、模板方法**

思想：创建一个框架，搭建框架的所有方法，但是只实现相同功能，可变功能只留接口不实现，留在子类实现。

该框架能够延森到其它子类中，具体功能将在子类实现时补充完毕。

**18、原型模式**

这个模式比较通用，通过javascript特有的原型继承实现继承方法都会使用到该种模式。ECMA5中的是使用Odject.create方法实现原型继承。大叔提到需要注意深拷贝和浅拷贝的问题。值引用方式为浅拷贝，值返回的方式是深拷贝。

**19、状态模式**

代码很多的一篇，一个模式足足200行。

使用该种模式有明确场景：

对象的行为跟对象的状态相关，运行时刻，状态改变讲改变对象的行为，对象的行为根据状态进行。

写这种代码确实是劳心劳力啊。T_T||。详细实现的时候再瞧瞧大叔的代码吧。

**20、桥接模式**

最简单的桥接模式，把一个可能在不同上下文下不能运行的函数，通过改变调用方式或者改变参数的方式达到运行的目的。这个方式就成为桥。

大叔的例子里面，代码是运行不鸟了，因为没有环境。主要思想就是在绑定动作的时候，直接的实现内容用户可以不知道，传输正确参数（如id）进去即可判断参数进行动作或者获取数据。



**总结：**

花了一个春节假期，把大叔的设计模式这一块看完了，从编码思想方面进行了改变。但是，设计模式并非看完就能真正掌握了，没有实践，永远只能在口中胡扯。

talk is cheap,show me the code.

速成设计模式，难，没基础学设计模式，难。学习设计模式的最佳方法不是看书就知道，而是看过了书知道，了解到其思想，在自己的编码实践中，结合进去，参考前人的代码进行该模式的实现，自然水到渠成。

这就是这篇文章的目的：设计模式的思想。

（并非做了精读，只做编程作参考，如有错误，恳请大力指出，谢谢。）